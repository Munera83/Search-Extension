/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@huggingface/inference@2.6.4/dist/index.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var e=Object.defineProperty,t={};function r(e){return/^http(s?):/.test(e)||e.startsWith("/")}((t,r)=>{for(var n in r)e(t,n,{get:r[n],enumerable:!0})})(t,{audioClassification:()=>g,audioToAudio:()=>b,automaticSpeechRecognition:()=>w,conversational:()=>T,documentQuestionAnswering:()=>M,featureExtraction:()=>j,fillMask:()=>B,imageClassification:()=>h,imageSegmentation:()=>A,imageToImage:()=>E,imageToText:()=>x,objectDetection:()=>v,questionAnswering:()=>q,request:()=>f,sentenceSimilarity:()=>C,streamingRequest:()=>p,summarization:()=>S,tableQuestionAnswering:()=>$,tabularClassification:()=>Q,tabularRegression:()=>R,textClassification:()=>O,textGeneration:()=>z,textGenerationStream:()=>U,textToImage:()=>k,textToSpeech:()=>m,tokenClassification:()=>I,translation:()=>W,visualQuestionAnswering:()=>P,zeroShotClassification:()=>N,zeroShotImageClassification:()=>H});var n=new Map,a=6e5,i=1e3,s="https://huggingface.co";async function o(e,t,o){if(r(e))return null;const c=`${e}:${t}`;let u=n.get(c);if(u&&u.date<new Date(Date.now()-a)&&(n.delete(c),u=void 0),void 0===u){const r=await(o?.fetch??fetch)(`${s}/api/models/${e}?expand[]=pipeline_tag`,{headers:t?{Authorization:`Bearer ${t}`}:{}}).then((e=>e.json())).then((e=>e.pipeline_tag)).catch((()=>null));if(!r)return null;u={task:r,date:new Date},n.set(c,{task:r,date:new Date}),n.size>i&&n.delete(n.keys().next().value)}return u.task}var c="https://api-inference.huggingface.co",u=null;async function y(e,t){const{accessToken:n,model:a,...i}=e;let{model:o}=e;const{forceTask:y,includeCredentials:f,taskHint:l,...p}=t??{},d={};if(n&&(d.Authorization=`Bearer ${n}`),!o&&!u&&l){const e=await fetch(`${s}/api/tasks`);e.ok&&(u=await e.json())}if(!o&&u&&l){const e=u[l];e&&(o=e.models[0].id)}if(!o)throw new Error("No model provided, and no default model found for this task");const g="data"in e&&!!e.data;g?(t?.wait_for_model&&(d["X-Wait-For-Model"]="true"),!1===t?.use_cache&&(d["X-Use-Cache"]="false"),t?.dont_load_model&&(d["X-Load-Model"]="0")):d["Content-Type"]="application/json";let w;"string"==typeof f?w=f:"boolean"==typeof f?w=f?"include":void 0:void 0===f&&(w="same-origin");return{url:r(o)?o:y?`${c}/pipeline/${y}/${o}`:`${c}/models/${o}`,info:{headers:d,method:"POST",body:g?e.data:JSON.stringify({...i,options:t&&p}),credentials:w,signal:t?.signal}}}async function f(e,t){const{url:r,info:n}=await y(e,t),a=await(t?.fetch??fetch)(r,n);if(!1!==t?.retry_on_error&&503===a.status&&!t?.wait_for_model)return f(e,{...t,wait_for_model:!0});if(!a.ok){if(a.headers.get("Content-Type")?.startsWith("application/json")){const e=await a.json();if(e.error)throw new Error(e.error)}throw new Error("An error occurred while fetching the blob")}return a.headers.get("Content-Type")?.startsWith("application/json")?await a.json():await a.blob()}function l(e){let t,r,n,a=!1;return function(i){void 0===t?(t=i,r=0,n=-1):t=function(e,t){const r=new Uint8Array(e.length+t.length);return r.set(e),r.set(t,e.length),r}(t,i);const s=t.length;let o=0;for(;r<s;){a&&(10===t[r]&&(o=++r),a=!1);let i=-1;for(;r<s&&-1===i;++r)switch(t[r]){case 58:-1===n&&(n=r-o);break;case 13:a=!0;case 10:i=r}if(-1===i)break;e(t.subarray(o,i),n),o=r,n=-1}o===s?t=void 0:0!==o&&(t=t.subarray(o),r-=o)}}async function*p(e,t){const{url:r,info:n}=await y({...e,stream:!0},t),a=await(t?.fetch??fetch)(r,n);if(!1!==t?.retry_on_error&&503===a.status&&!t?.wait_for_model)return p(e,{...t,wait_for_model:!0});if(!a.ok){if(a.headers.get("Content-Type")?.startsWith("application/json")){const e=await a.json();if(e.error)throw new Error(e.error)}throw new Error(`Server response contains error: ${a.status}`)}if(!a.headers.get("content-type")?.startsWith("text/event-stream"))throw new Error("Server does not support event stream content type, it returned "+a.headers.get("content-type"));if(!a.body)return;const i=a.body.getReader();let s=[];const o=l(function(e,t,r){let n={data:"",event:"",id:"",retry:void 0};const a=new TextDecoder;return function(i,s){if(0===i.length)r?.(n),n={data:"",event:"",id:"",retry:void 0};else if(s>0){const r=a.decode(i.subarray(0,s)),o=s+(32===i[s+1]?2:1),c=a.decode(i.subarray(o));switch(r){case"data":n.data=n.data?n.data+"\n"+c:c;break;case"event":n.event=c;break;case"id":e(n.id=c);break;case"retry":const r=parseInt(c,10);isNaN(r)||t(n.retry=r)}}}}((()=>{}),(()=>{}),(e=>{s.push(e)})));try{for(;;){const{done:e,value:t}=await i.read();if(e)return;o(t);for(const e of s)if(e.data.length>0){const t=JSON.parse(e.data);if("object"==typeof t&&null!==t&&"error"in t)throw new Error(t.error);yield t}s=[]}}finally{i.releaseLock()}}var d=class extends TypeError{constructor(e){super(`Invalid inference output: ${e}. Use the 'request' method with the same parameters to do a custom call with no type checking.`),this.name="InferenceOutputError"}};async function g(e,t){const r=await f(e,{...t,taskHint:"audio-classification"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e.label&&"number"==typeof e.score))))throw new d("Expected Array<{label: string, score: number}>");return r}async function w(e,t){const r=await f(e,{...t,taskHint:"automatic-speech-recognition"});if(!("string"==typeof r?.text))throw new d("Expected {text: string}");return r}async function m(e,t){const r=await f(e,{...t,taskHint:"text-to-speech"});if(!(r&&r instanceof Blob))throw new d("Expected Blob");return r}async function b(e,t){const r=await f(e,{...t,taskHint:"audio-to-audio"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e.label&&"string"==typeof e.blob&&"string"==typeof e["content-type"]))))throw new d("Expected Array<{label: string, blob: string, content-type: string}>");return r}async function h(e,t){const r=await f(e,{...t,taskHint:"image-classification"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e.label&&"number"==typeof e.score))))throw new d("Expected Array<{label: string, score: number}>");return r}async function A(e,t){const r=await f(e,{...t,taskHint:"image-segmentation"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e.label&&"string"==typeof e.mask&&"number"==typeof e.score))))throw new d("Expected Array<{label: string, mask: string, score: number}>");return r}async function x(e,t){const r=(await f(e,{...t,taskHint:"image-to-text"}))?.[0];if("string"!=typeof r?.generated_text)throw new d("Expected {generated_text: string}");return r}async function v(e,t){const r=await f(e,{...t,taskHint:"object-detection"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e.label&&"number"==typeof e.score&&"number"==typeof e.box.xmin&&"number"==typeof e.box.ymin&&"number"==typeof e.box.xmax&&"number"==typeof e.box.ymax))))throw new d("Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>");return r}async function k(e,t){const r=await f(e,{...t,taskHint:"text-to-image"});if(!(r&&r instanceof Blob))throw new d("Expected Blob");return r}function _(e){if(globalThis.Buffer)return globalThis.Buffer.from(e).toString("base64");{const t=[];return e.forEach((e=>{t.push(String.fromCharCode(e))})),globalThis.btoa(t.join(""))}}async function E(e,t){let r;r=e.parameters?{...e,inputs:_(new Uint8Array(e.inputs instanceof ArrayBuffer?e.inputs:await e.inputs.arrayBuffer()))}:{accessToken:e.accessToken,model:e.model,data:e.inputs};const n=await f(r,{...t,taskHint:"image-to-image"});if(!(n&&n instanceof Blob))throw new d("Expected Blob");return n}async function H(e,t){const r={...e,inputs:{image:_(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},n=await f(r,{...t,taskHint:"zero-shot-image-classification"});if(!(Array.isArray(n)&&n.every((e=>"string"==typeof e.label&&"number"==typeof e.score))))throw new d("Expected Array<{label: string, score: number}>");return n}async function T(e,t){const r=await f(e,{...t,taskHint:"conversational"});if(!(Array.isArray(r.conversation.generated_responses)&&r.conversation.generated_responses.every((e=>"string"==typeof e))&&Array.isArray(r.conversation.past_user_inputs)&&r.conversation.past_user_inputs.every((e=>"string"==typeof e))&&"string"==typeof r.generated_text&&(void 0===r.warnings||Array.isArray(r.warnings)&&r.warnings.every((e=>"string"==typeof e)))))throw new d("Expected {conversation: {generated_responses: string[], past_user_inputs: string[]}, generated_text: string, warnings: string[]}");return r}async function j(e,t){const r=e.model?await o(e.model,e.accessToken,t):void 0,n=await f(e,{...t,taskHint:"feature-extraction",..."sentence-similarity"===r&&{forceTask:"feature-extraction"}});let a=!0;const i=(e,t,r=0)=>!(r>t)&&(e.every((e=>Array.isArray(e)))?e.every((e=>i(e,t,r+1))):e.every((e=>"number"==typeof e)));if(a=Array.isArray(n)&&i(n,3,0),!a)throw new d("Expected Array<number[][][] | number[][] | number[] | number>");return n}async function B(e,t){const r=await f(e,{...t,taskHint:"fill-mask"});if(!(Array.isArray(r)&&r.every((e=>"number"==typeof e.score&&"string"==typeof e.sequence&&"number"==typeof e.token&&"string"==typeof e.token_str))))throw new d("Expected Array<{score: number, sequence: string, token: number, token_str: string}>");return r}async function q(e,t){const r=await f(e,{...t,taskHint:"question-answering"});if(!("object"==typeof r&&!!r&&"string"==typeof r.answer&&"number"==typeof r.end&&"number"==typeof r.score&&"number"==typeof r.start))throw new d("Expected {answer: string, end: number, score: number, start: number}");return r}async function C(e,t){const r=e.model?await o(e.model,e.accessToken,t):void 0,n=await f(e,{...t,taskHint:"sentence-similarity",..."feature-extraction"===r&&{forceTask:"sentence-similarity"}});if(!(Array.isArray(n)&&n.every((e=>"number"==typeof e))))throw new d("Expected number[]");return n}async function S(e,t){const r=await f(e,{...t,taskHint:"summarization"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e?.summary_text))))throw new d("Expected Array<{summary_text: string}>");return r?.[0]}async function $(e,t){const r=await f(e,{...t,taskHint:"table-question-answering"});if(!("string"==typeof r?.aggregator&&"string"==typeof r.answer&&Array.isArray(r.cells)&&r.cells.every((e=>"string"==typeof e))&&Array.isArray(r.coordinates)&&r.coordinates.every((e=>Array.isArray(e)&&e.every((e=>"number"==typeof e))))))throw new d("Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}");return r}async function O(e,t){const r=(await f(e,{...t,taskHint:"text-classification"}))?.[0];if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e?.label&&"number"==typeof e.score))))throw new d("Expected Array<{label: string, score: number}>");return r}async function z(e,t){const r=await f(e,{...t,taskHint:"text-generation"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e?.generated_text))))throw new d("Expected Array<{generated_text: string}>");return r?.[0]}async function*U(e,t){yield*p(e,{...t,taskHint:"text-generation"})}function D(e){return Array.isArray(e)?e:[e]}async function I(e,t){const r=D(await f(e,{...t,taskHint:"token-classification"}));if(!(Array.isArray(r)&&r.every((e=>"number"==typeof e.end&&"string"==typeof e.entity_group&&"number"==typeof e.score&&"number"==typeof e.start&&"string"==typeof e.word))))throw new d("Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>");return r}async function W(e,t){const r=await f(e,{...t,taskHint:"translation"});if(!(Array.isArray(r)&&r.every((e=>"string"==typeof e?.translation_text))))throw new d("Expected type Array<{translation_text: string}>");return r?.[0]}async function N(e,t){const r=D(await f(e,{...t,taskHint:"zero-shot-classification"}));if(!(Array.isArray(r)&&r.every((e=>Array.isArray(e.labels)&&e.labels.every((e=>"string"==typeof e))&&Array.isArray(e.scores)&&e.scores.every((e=>"number"==typeof e))&&"string"==typeof e.sequence))))throw new d("Expected Array<{labels: string[], scores: number[], sequence: string}>");return r}async function M(e,t){const r={...e,inputs:{question:e.inputs.question,image:_(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},n=D(await f(r,{...t,taskHint:"document-question-answering"}))?.[0];if(!!("string"!=typeof n?.answer||"number"!=typeof n.end&&void 0!==n.end||"number"!=typeof n.score&&void 0!==n.score||"number"!=typeof n.start&&void 0!==n.start))throw new d("Expected Array<{answer: string, end?: number, score?: number, start?: number}>");return n}async function P(e,t){const r={...e,inputs:{question:e.inputs.question,image:_(new Uint8Array(e.inputs.image instanceof ArrayBuffer?e.inputs.image:await e.inputs.image.arrayBuffer()))}},n=(await f(r,{...t,taskHint:"visual-question-answering"}))?.[0];if(!("string"==typeof n?.answer&&"number"==typeof n.score))throw new d("Expected Array<{answer: string, score: number}>");return n}async function R(e,t){const r=await f(e,{...t,taskHint:"tabular-regression"});if(!(Array.isArray(r)&&r.every((e=>"number"==typeof e))))throw new d("Expected number[]");return r}async function Q(e,t){const r=await f(e,{...t,taskHint:"tabular-classification"});if(!(Array.isArray(r)&&r.every((e=>"number"==typeof e))))throw new d("Expected number[]");return r}var X=class{accessToken;defaultOptions;constructor(e="",r={}){this.accessToken=e,this.defaultOptions=r;for(const[n,a]of Object.entries(t))Object.defineProperty(this,n,{enumerable:!1,value:(t,n)=>a({...t,accessToken:e},{...r,...n})})}endpoint(e){return new G(e,this.accessToken,this.defaultOptions)}},G=class{constructor(e,r="",n={}){for(const[a,i]of Object.entries(t))Object.defineProperty(this,a,{enumerable:!1,value:(t,a)=>i({...t,accessToken:r,model:e},{...n,...a})})}};export{X as HfInference,G as HfInferenceEndpoint,d as InferenceOutputError,g as audioClassification,b as audioToAudio,w as automaticSpeechRecognition,T as conversational,M as documentQuestionAnswering,j as featureExtraction,B as fillMask,h as imageClassification,A as imageSegmentation,E as imageToImage,x as imageToText,v as objectDetection,q as questionAnswering,f as request,C as sentenceSimilarity,p as streamingRequest,S as summarization,$ as tableQuestionAnswering,Q as tabularClassification,R as tabularRegression,O as textClassification,z as textGeneration,U as textGenerationStream,k as textToImage,m as textToSpeech,I as tokenClassification,W as translation,P as visualQuestionAnswering,N as zeroShotClassification,H as zeroShotImageClassification};export default null;
//# sourceMappingURL=/sm/ed9353d75b7e5592d7acd9329772f086db1ca9db4ef1b4058e1117c9e3db0544.map